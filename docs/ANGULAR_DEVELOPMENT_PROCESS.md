# Процесс разработки веб-приложения на Angular с интеграцией REST API

## Введение

Разработка веб-приложения для управления линиями электропередач осуществлялась с использованием современного стека технологий, включающего Angular в качестве фронтенд-фреймворка, FastAPI для бэкенд-сервера и PostgreSQL в качестве системы управления базами данных. Ключевой задачей разработки являлось обеспечение надежной интеграции между клиентской и серверной частями приложения, что требовало тщательной синхронизации моделей данных и согласования архитектурных решений между различными технологическими платформами.

## Архитектура фронтенд-приложения

Фронтенд-приложение построено на базе Angular версии 15 с использованием модульной архитектуры, что обеспечивает разделение функциональности на независимые модули и компоненты. Структура приложения организована по принципу feature-based architecture, где каждый функциональный модуль содержит собственные компоненты, сервисы и модели данных. Основными модулями приложения являются модуль аутентификации, модуль работы с картой, модуль управления объектами (ЛЭП, опоры, подстанции) и модуль синхронизации данных.

*См. структуру модулей: `web-frontend/src/app/app.module.ts:49-58`, `web-frontend/src/app/features/`*

Центральным элементом архитектуры является система сервисов, реализованная через механизм dependency injection Angular. Сервис ApiService выступает в качестве единой точки взаимодействия с REST API, инкапсулируя всю логику HTTP-запросов и обеспечивая типизацию данных через TypeScript интерфейсы. Сервис MapService предоставляет абстракцию для работы с картографическими данными, преобразуя GeoJSON-формат, получаемый от сервера, в структуры данных, понятные компонентам карты. Сервис AuthService управляет состоянием аутентификации пользователя, храня JWT-токены в localStorage и обеспечивая их автоматическое добавление в заголовки всех HTTP-запросов через механизм HTTP-интерцепторов.

*См. реализацию сервисов: `web-frontend/src/app/core/services/api.service.ts:15-131`, `web-frontend/src/app/core/services/map.service.ts:16-74`, `web-frontend/src/app/core/services/auth.service.ts:11-97`, `web-frontend/src/app/core/services/auth.service.ts:86-88` (хранение токена в localStorage)*

## Реализованный функционал

В процессе разработки была реализована комплексная система управления объектами энергетической инфраструктуры. Основным функциональным модулем является интерактивная карта, построенная на базе библиотеки Leaflet, которая отображает линии электропередач, опоры, отпайки и подстанции в виде геопространственных объектов. Карта поддерживает масштабирование с динамическим отображением подписей опор в зависимости от уровня зума, центрирование на выбранных объектах и отображение всплывающих окон с информацией о свойствах объектов при клике на маркеры.

*См. реализацию карты: `web-frontend/src/app/features/map/map.component.ts:18-523`, `web-frontend/src/app/features/map/map.component.ts:363-390` (динамические подписи опор), `web-frontend/src/app/features/map/map.component.ts:268-280` (обработка клика на маркеры)*

Система управления объектами включает функционал создания новых ЛЭП и опор через модальные диалоговые окна с валидацией данных на стороне клиента. Диалог создания объекта реализован с использованием Angular Material Dialog, что обеспечивает единообразный пользовательский интерфейс и интеграцию с системой форм Angular Reactive Forms. Валидация данных осуществляется как на клиентской стороне через встроенные валидаторы Angular, так и на серверной стороне через Pydantic схемы FastAPI, что обеспечивает двойную защиту от некорректных данных.

*См. диалог создания объектов: `web-frontend/src/app/features/map/create-object-dialog/create-object-dialog.component.ts:67-80` (валидация формы опоры), `web-frontend/src/app/features/map/create-object-dialog/create-object-dialog.component.ts:342-367` (валидаторы координат), `backend/app/schemas/power_line.py:30-40` (Pydantic схемы валидации)*

Дерево объектов, реализованное в боковой панели приложения, предоставляет иерархическое представление структуры энергетической сети с возможностью раскрытия и сворачивания узлов. Дерево организовано по принципу вложенности: линии электропередач содержат сегменты, которые в свою очередь содержат опоры. При клике на объект в дереве происходит центрирование карты на соответствующем географическом объекте с применением специальной логики зума, которая учитывает текущий уровень масштабирования карты.

*См. реализацию дерева объектов: `web-frontend/src/app/layout/sidebar/sidebar.component.ts:89-160` (построение иерархии), `web-frontend/src/app/layout/sidebar/sidebar.component.html:9-79` (шаблон дерева), `web-frontend/src/app/layout/sidebar/sidebar.component.ts:219-267` (логика центрирования и зума)*

Функционал удаления объектов реализован через контекстное меню, вызываемое правой кнопкой мыши на элементах дерева объектов. При вызове контекстного меню открывается диалоговое окно подтверждения удаления, которое после подтверждения отправляет DELETE-запрос на соответствующий endpoint API и обновляет данные на карте и в дереве объектов после успешного удаления.

*См. реализацию удаления: `web-frontend/src/app/layout/sidebar/sidebar.component.ts:274-320` (обработчик правой кнопки мыши), `web-frontend/src/app/features/map/delete-object-dialog/delete-object-dialog.component.ts:42-101` (диалог подтверждения), `web-frontend/src/app/core/services/api.service.ts:77-79` (DELETE запрос), `backend/app/api/v1/poles.py:32-56` (endpoint удаления)*

## Интеграция фронтенда и бэкенда

Интеграция между клиентской и серверной частями приложения осуществляется через REST API, построенный на базе FastAPI. Все HTTP-запросы проходят через единый сервис ApiService, который обеспечивает типизацию данных через TypeScript интерфейсы, соответствующие Pydantic схемам на сервере. Это обеспечивает статическую проверку типов на этапе компиляции и предотвращает ошибки, связанные с несоответствием структуры данных.

*См. REST API сервис: `web-frontend/src/app/core/services/api.service.ts:15-131`, `backend/app/main.py:105-112` (регистрация роутеров), `backend/app/api/v1/power_lines.py:16-114` (пример endpoint)*

Механизм аутентификации реализован через JWT-токены, которые передаются в заголовке Authorization всех HTTP-запросов. Автоматическое добавление токена обеспечивается через HTTP-интерцептор AuthInterceptor, который перехватывает все исходящие запросы и добавляет заголовок с токеном, если пользователь аутентифицирован. Это позволяет централизованно управлять аутентификацией без необходимости явного указания токена в каждом запросе.

*См. реализацию аутентификации: `web-frontend/src/app/core/interceptors/auth.interceptor.ts:7-24`, `web-frontend/src/app/core/services/auth.service.ts:25-46` (логин), `web-frontend/src/app/app.module.ts:92-97` (регистрация интерцептора), `backend/app/api/v1/auth.py` (endpoint аутентификации)*

Обработка ошибок реализована через второй HTTP-интерцептор ErrorInterceptor, который перехватывает все ответы сервера и обрабатывает ошибки, преобразуя их в понятные пользователю сообщения. При получении ошибки 401 (Unauthorized) интерцептор автоматически перенаправляет пользователя на страницу входа, а при других ошибках отображает уведомления через Angular Material Snackbar.

*См. обработку ошибок: `web-frontend/src/app/core/interceptors/error.interceptor.ts`, `web-frontend/src/app/app.module.ts:98-102` (регистрация интерцептора), `web-frontend/src/app/features/map/create-object-dialog/create-object-dialog.component.ts:482-555` (обработка ошибок валидации)*

## Синхронизация моделей данных между фронтендом и бэкендом

Одной из ключевых проблем, решенных в процессе разработки, являлась синхронизация моделей данных между TypeScript интерфейсами на фронтенде и Pydantic схемами на бэкенде. Различия в системах типизации между языками программирования требовали тщательного согласования структур данных.

На бэкенде модели данных определены в нескольких слоях: SQLAlchemy модели для работы с базой данных, Pydantic схемы для валидации входных и выходных данных API, и промежуточные структуры для преобразования данных между слоями. Например, модель PowerLine в SQLAlchemy содержит поля id, mrid, name, code, voltage_level и другие, которые автоматически преобразуются в Pydantic схему PowerLineResponse при возврате данных клиенту.

*См. модели данных на бэкенде: `backend/app/models/power_line.py:7-36` (SQLAlchemy модель PowerLine), `backend/app/schemas/power_line.py:30-50` (Pydantic схемы PowerLineCreate и PowerLineResponse), `backend/app/api/v1/power_lines.py:18-114` (преобразование между слоями)*

На фронтенде соответствующие интерфейсы TypeScript должны точно соответствовать структуре данных, возвращаемых сервером. Интерфейс PowerLine на фронтенде содержит те же поля, что и PowerLineResponse на бэкенде, но с учетом особенностей TypeScript: опциональные поля помечаются символом вопроса, типы данных адаптированы под TypeScript (например, datetime на Python преобразуется в string на TypeScript для JSON-сериализации).

*См. интерфейсы на фронтенде: `web-frontend/src/app/core/models/power-line.model.ts:1-26` (интерфейс PowerLine), `web-frontend/src/app/core/models/pole.model.ts:1-32` (интерфейс Pole), сравните с `backend/app/schemas/power_line.py:20-28` (Pydantic схема PoleResponse)*

Особую сложность представляла синхронизация при изменении структуры данных. Например, при добавлении нового поля в модель на бэкенде необходимо было обновить соответствующий интерфейс на фронтенде, иначе TypeScript не мог корректно обработать ответ сервера. Для решения этой проблемы был разработан процесс, при котором изменения в моделях данных сначала вносятся на бэкенде, затем создаются соответствующие интерфейсы на фронтенде, и только после этого изменения тестируются в интеграции.

## Проблемы совместимости и их решения

В процессе разработки возникали проблемы, связанные с различиями в обработке данных между различными технологическими платформами. Одной из таких проблем являлось несоответствие имен полей между фронтендом и бэкендом. Например, в Python принято использовать snake_case для имен переменных (power_line_id), в то время как в TypeScript часто используется camelCase (powerLineId). Для решения этой проблемы было принято решение использовать snake_case на обеих сторонах, что соответствует конвенциям REST API и упрощает интеграцию.

*См. примеры использования snake_case: `web-frontend/src/app/core/models/power-line.model.ts:4-9` (power_line_id, voltage_level), `backend/app/models/power_line.py:15-16` (voltage_level, length), `backend/app/schemas/power_line.py:32-33` (voltage_level, length)*

Другая проблема была связана с обработкой опциональных полей и значений по умолчанию. В Pydantic схемах можно указать значения по умолчанию для полей, которые не передаются клиентом, но в TypeScript интерфейсах такие поля должны быть помечены как опциональные. Это требовало тщательной синхронизации между схемами валидации на сервере и интерфейсами на клиенте.

*См. опциональные поля: `backend/app/schemas/power_line.py:32-37` (Optional[float] = None, status: str = "active"), `web-frontend/src/app/core/models/power-line.model.ts:7-11` (voltage_level?: number, length?: number, status: string)*

Особую сложность представляла обработка ошибок валидации. FastAPI возвращает ошибки валидации в специфическом формате, который включает информацию о поле, типе ошибки и сообщении. На фронтенде необходимо было преобразовать эту структуру в понятные пользователю сообщения, учитывая особенности русского языка и контекст конкретного поля формы.

*См. обработку ошибок валидации: `web-frontend/src/app/features/map/create-object-dialog/create-object-dialog.component.ts:514-544` (парсинг ошибок FastAPI), `web-frontend/src/app/features/map/create-object-dialog/create-object-dialog.component.ts:557-601` (преобразование в сообщения для пользователя)*

## Работа с геопространственными данными

Интеграция картографического функционала требовала преобразования данных между различными форматами. Сервер возвращает данные в формате GeoJSON, который является стандартным форматом для обмена геопространственными данными. На фронтенде эти данные преобразуются в объекты Leaflet (маркеры, полилинии), которые отображаются на карте.

*См. работу с GeoJSON: `backend/app/api/v1/map_tiles.py:67-102` (генерация GeoJSON для опор), `web-frontend/src/app/core/services/map.service.ts:21-28` (загрузка GeoJSON данных), `web-frontend/src/app/features/map/map.component.ts:221-243` (преобразование GeoJSON в Leaflet полилинии), `web-frontend/src/app/features/map/map.component.ts:245-292` (преобразование GeoJSON в Leaflet маркеры)*

Особенностью работы с геопространственными данными являлась необходимость синхронизации координат между различными системами координат. Сервер хранит координаты в системе WGS84 (широта и долгота), которые используются Leaflet по умолчанию, что упрощает интеграцию. Однако при расчете расстояний и масштабирования необходимо учитывать проекцию Web Mercator, используемую Leaflet для отображения карты.

*См. расчет расстояний: `web-frontend/src/app/features/map/map.component.ts:45-76` (расчет разрешения и расстояния для Web Mercator), `web-frontend/src/app/features/map/map.component.ts:115-154` (инициализация карты Leaflet), `backend/app/models/power_line.py:48-49` (хранение координат в WGS84)*

*См. расчет расстояний: `web-frontend/src/app/features/map/map.component.ts:45-76` (расчет разрешения и расстояния для Web Mercator), `web-frontend/src/app/features/map/map.component.ts:115-154` (инициализация карты Leaflet), `backend/app/models/power_line.py:48-49` (хранение координат в WGS84)*

## Процесс разработки и тестирования

Разработка велась итеративно, с постепенным добавлением функциональности. Сначала была реализована базовая структура приложения с модулями и сервисами, затем добавлена функциональность аутентификации, после чего реализована работа с картой и объектами. На каждом этапе разработки проводилось тестирование интеграции между фронтендом и бэкендом, что позволяло выявлять проблемы совместимости на ранних стадиях.

Тестирование интеграции осуществлялось через ручное тестирование функциональности и проверку соответствия данных, передаваемых между клиентом и сервером. Для отладки использовались инструменты разработчика браузера для просмотра HTTP-запросов и ответов, а также логирование на сервере для отслеживания обработки запросов.

## Заключение

Разработка веб-приложения на Angular с интеграцией REST API потребовала решения множества задач, связанных с синхронизацией моделей данных, обработкой ошибок и обеспечением надежной коммуникации между клиентом и сервером. Использование типизированных интерфейсов TypeScript и Pydantic схем на бэкенде позволило обеспечить статическую проверку типов и предотвратить многие ошибки на этапе разработки. Архитектура приложения, основанная на модульности и разделении ответственности, обеспечивает возможность дальнейшего расширения функциональности и поддержки кода.
